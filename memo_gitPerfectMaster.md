# もう怖くないGit! チーム開発で必要なGitを完全マスター! 山浦講師

## Gitの設定

.gitconfig に登録したnameとemail

$ git config --global user.name [name]

git で使うエディターを登録 => $ git config --global core.editor "atom --wait"

設定の確認 => $ git config user.name, $ git config user.email

一度に確認したければ => $ git config --list

## Gitは差分でなく、スナップショットを保存している

branchを切る際やmergeする際に、スナップショットだと作業が早い。差分だと、いちいち計算しないといけない。

コミットが、直前のコミットを記録している。

## gitの作業の流れ

ワークツリーでファイルを変更

git add：コミットする変更を準備(記録したい変更分だけをstageに切り分けておく)

git commit：ステージに追加された変更を、スナップショットとしてリポジトリに記録

## コマンドの裏で何が起きているのか〜Gitのデータの持ち方（コミットまでの流れ）

### index.htmlをステージに追加する時、何が起こっているか。

index.html の圧縮ファイルAをリポジトリに保存。（実際は、ファイルの中身にヘッダを付け加えた文字列を、ハッシュ関数で暗号化した文字列がファイル名となる）

git add == ファイル名(index.html)と圧縮ファイルA（ファイルの中身）をmappingした情報をインデックスに保存。

git commit == インデックスのファイル構成を元に、ツリー1というファイルが作られる。次にコミット1というファイルを作る。

コミット1には、ツリー１（ファイル名）、作成者、日付、コミットメッセージが記録される。コミット1から、その時のファイル状態(snap shot)と、誰がいつ何のために変更したのかがわかる。

gitはステージに追加してコミットする際、圧縮ファイル、ツリー、コミットという3種類のファイルを作成してデータを保存している。

### 新しいファイル、css/home.cssを追加したら

git add == css/home.cssの圧縮ファイルBが作成される。インデックスにファイル構成を追記する。

git commit == ツリー2が作成され、インデックスに記載されているファイル構成が保存される。コミット2が作成され、ツリー2というツリー名が記録される。直前のコミット（コミット1）を、自分の親コミットとして記録する。（変更履歴を連鎖してたどれるように）

ステージに追加した時はインデックスという一つのファイルに上書きしておいて、コミット（きちんと記録）する時だけ、ツリーというファイルに保存する。

### ファイルを変更したら

index.htmlだけを変更すると、index.htmlを圧縮した圧縮ファイルCのみがつくられる（圧縮ファイルは、ファイルの中身が違う時だけつくられる）。

インデックスファイルの情報が、index.htmlの圧縮ファイルがAからCに書き換えられる。ここまでが　[$ git add]

ツリー3が作成され、コミット3のツリーはツリー3、親コミットはコミット2となる。[$ git commit]

### Gitのデータ構造のまとめ

リポジトリに「圧縮ファイル」「ツリー」「コミット」ファイルを作成することでデータを保存。ステージに追加する時に「圧縮ファイル」が、コミットする時に「ツリー」「コミット」ファイルが作られる。

コミットが、親コミットへの参照を持つことで、変更履歴をたどることができる。

Gitの本質は、データを圧縮して、スナップショットで保存していること。

## .gitの中身は？

$ ls .git =>  COMMIT_EDITMSG  HEAD  config  description  hooks  index  info  logs  objects  refs

objects：圧縮ファイルやツリーファイル、コミットファイルが保存される、リポジトリの本体

config：Gitの設定ファイル。

## GitHub上にすでにあるプロジェクトから始める

$ git clone <リポジトリ名> => リモートリポジトリのファイルがワークツリーにコピーされ、.gitリポジトリがコピーされる。

### 変更を記録する(commit)

~$ git commit ：Gitのテキストエディターが立ち上がって、メッセージ付きで保存

~$ git commit -m <メッセージ>：いちいち、エディターを立ち上げなくて済む

~$ git commit -v ：エディターが立ち上がり、ファイルの変更内容を確認することができる。

### コミットメッセージの正式な書き方

1行目＝変更内容の要約、2行目＝改行、3行目＝変更した理由（チーム内、オープンソースへのコミットには正式な記法で！）

### 現コミットやステージ追加の前に、どのファイルが変更されたか確認する！

git status => ワークツリーとステージ、ステージとリポジトリの間で変更されたファイルを表示している。

### 変更差分を確認する

$ git diff (<ファイル名>)：git add する前の変更分を確認（ワークツリート、ステージの変更差分）

$ git diff --staged：git add した後の変更分を確認（ステージとコミットの変更差分）

### 変更履歴の確認

$ git log --oneline ：1行で表示、 $ git log -p <ファイル名>：特定ファイルの変更分を表示、$ git log -n <コミット数>：表示するコミット数を指定
    
git log で表示されるハッシュ値は、コミットのIDのようなもの。

### ファイルの削除を記録する

コミットされた記録だけでなく、ワークツリーのファイルごと削除したい =>　$ git rm <ファイル名> / $ git rm -r <ディレクトリ名>

ワークツリーにファイルは残したいが、Gitの記録からだけファイルを削除したい =>　$ git rm --cached <ファイル名>

例えば、passWordの入ったファイルを間違ってGitにあげてしまったような時は、gir rm --cachedを使う。

### 元の状態に戻す

git rm で削除したファイルを元に戻すには $ git reset HEAD <ファイル名> に続いて、$ git checkout <ファイル名>

この2段構えでファイルが復活し、git status で見ても「変更点がなく」なる。コマンドの意味は、後で詳しく。

git rm --cached index.html を実行すると、ファイルは残っている。git status では、Changes to be commited（コミットすべき変更）として、index.html がdeletedされたこと、Untracked files（Gitで追跡していない、新規ファイル）としてindex.htmlがある、と表示される。

git rm --cached でGitの記録から削除したファイルも、 git reset HEAD index.html で元に戻せる。

### ファイルの移動を記録する

$ git mv <旧ファイル> <新ファイル> これは、下記の3連続コマンドと等価。

$ mv <旧ファイル> <新ファイル> => $ git rm <旧ファイル> => $ git add <新ファイル>

## GitHubにプッシュする

チームメンバーに自分の開発したコードを共有する時、GitHubにローカルの内容を保存したい時。

### リモートリポジトリ(GitHub)を新規追加

$ git remote add origin https://github.com/user/repo.git <-- originというショートカットでurlのリモートリポジトリを登録するよ

今後はoriginという名前で、GitHubリポジトリにアップしたり、取得できるようになる（いちいち、URLを入力せずにすむ）

'origin'はGitの慣用句みたいなもの。git cloneをしてきた時に、clone元のもともとのリモートリポジトリをgitではorigin というショートカットに割り当てている。そのため、メインのリモートリポジトリのことを通常、originと名付ける。

### リモートリポジトリ(GitHub)に送信

$ git push <リモート名> <ブランチ名> 具体的には $ git push origin master

$ git push -u origin master <-- 初回プッシュ時にオプション -u をつけると次回以降は [git push]だけでpushできる。

### GitHubの画面

<>Code でファイルを選択してクリック。Rawは生ファイル、Blameは変更の責任者、Historyはコミット履歴

<>Codeを押して元のページに戻る。commits は個別ファイルのコミット履歴であるHistoryとは異なり、プロジェクト自体のコミット履歴を確認できる。

Clone or download <--他の人のプロジェクトから始めたい場合など

## コマンドにエイリアスをつける

$ git config --global alias.ci commit などで入力を楽に。--globalをつけるとPC全体の設定として~/.gitconfig (or ~/.config/git/config)に反映される。

--globalをつけなければ、今自分がいるプロジェクトの下の　project/.git/configに設定が反映される。

## 管理したくないファイルを無視するには

パスワードなど機密情報が書かれたファイルはバージョン管理から外す。<-- AWSなどのサーバーのpwをバージョン管理してしまい、それが流出・悪用されて多額の請求されるという事故が頻発。

チーム開発で不要なファイル。<- 自動生成されるファイルやキャッシュ。

### .gitignoreファイルの書き方

コメントは #で始める

index.html <- 指定したファイルを除外

/root.html <- ルートディレクトリ(プロジェクトのてっぺん)を指定

dir/ <- ディレクトリ以下を除外(ディレクトリに'/'をつなげる)

/*/*.css <- 一つ下の階層にあるcssファイルすべて

.gitignore を作成したら、それ自体を git add, git commitする。

### ファイルへの変更を取り消す（ワークツリーの）

$ git checkout -- <ファイル名 or ディレクトリ名>

$ git checkout -- . <- 全変更を取り消す

git checkout はブランチの変更の時にも使う。ブランチ名とファイル名が被った時に判別できるように、-- をつける。

### ステージに追加した変更を元に戻す

$ git reset HEAD <ファイル名 or ディレクトリ名>

$ git reset HEAD . <- 全変更を取り消す

このコマンドは、変更をステージから取り消すだけなので、ワークツリー（ローカル）のファイルそのものには影響を与えない。ワークツリーのファイルの変更も取り消したい場合は、git reset HEADをして、その後に、git checkout コマンドでファイルの変更を取り消す必要がある。

git reset コマンドは裏側で何をやっているか。リポジトリから最新コミットの情報を取ってきて、その情報でステージの内容を上書きしている。

HEADとは、今自分がいるブランチの最新のコミットのこと。つまり、$ git reset HEAD = 「最新のコミットの内容でリセット（ステージを上書き）する」

もしgit reset コマンドを忘れても、git statusを打つと(use "git reset HEAD <ファイル名>..." to unstage)と親切に教えてくれる。

### 直前のコミットをやり直す

$ git commit --amend : 今のステージの内容でコミットを上書きする。

!! リモートリポジトリにpushしたコミットは、絶対に修正してはいけない。修正可能なのは、あくまでpushする前のみ！

pushした後に、そのコミットをやり直したい場合は、git commitコマンドでもう一度新しくコミットを作って修正する。

### リモートを表示する

$ git remote : 登録されているリモート名しか表示されない。

$ git remote -v : 対応するURLを表示する。fetch とpushでURLを切り替えることもできるので二つのURLが表示される。

### リモートリポジトリは複数登録できる

チーム開発とは別に、自分でもリモートリポジトリを持っておきたい場合や、複数のチームでやりとりしていて、それぞれのチームでリポジトリを持っている場合など。

$ git remote add <リモート名> <リモートURL> : 例えば、リモート名をorigin でなく bakにしてバックアップ用リポジトリを登録とかできる。（bakというショートカットでリモートリポジトリを登録）

### リモートから取得しよう（fetch編）

$ git fetch <リモート名> : fetch =「取ってくる」

git fetch ではローカルリポジトリに情報を取得してくるだけで、ワークツリー（手元のファイル）には反映されない。

ローカルリポジトリの、remotes/リモート/ブランチ に保存される。

$ git merge : ローカルリポジトリに落として来た内容を、自分のワークツリーにmerge（統合）して反映させる。

(練習用に)リモートリポジトリ上で、新規ファイル（home.html）を作成。Create new file -> Commit directly to the master branch -> Commit new file

$ git fetch origin で情報を取ってくる。どこに保存されているのか？

$ git branch -a ：git branch の全部の情報を表示(-a はall)すると、remotes/origin/master というブランチができている。今いるブランチに * がつく。

先ほどの変更が反映されている remotes/origin/masterの中身を確認するには 

$ git checkout remotes/origin/master ：remotes/origin/master の方に、自分のワークツリーの内容を切り替える

ls で確認すると リモートリポジトリでの変更の反映が確認できる。（新規ファイルhome.htmlがある）

git fetchコマンドで、remotes/origin/master に情報が取得された。

$ git checkout master で元の状態に戻り、lsで確認すると、home.htmlがなく、元々の情報に戻っている。

$ git merge origin/master ：取得してきたリモートリポジトリの情報を、ワークツリーに取り込む。

!! コミットメッセージのエディターが立ち上がらない

git fetch でローカルリポジトリに情報を取得して、その情報をワークツリーに反映させたい場合は git merge コマンドを使う。

### リモートから取得しよう（pull編）

$ git pull <リモート名> <ブランチ名>：リモートから情報を取得してmergeまでを、一つの手順でやりたい時、pullを使う。

$ git pull origin master は $ git pull に省略可能。

$ git pull === ($ git fetch origin master) + ($ git merge origin/master) / fetch とmergeを一度にやるのがpull

git pull を使うと、リモートリポジトリの内容をローカルリポジトリに反映させて、その上で、ワークツリーにもその変更を一度に反映する。ワークツリーまで一度に変更反映したい場合は、git pull

### fetchとpullの使い分け

フェッチを基本的に使うのがおすすめ。プルは確かに楽ではあるが、挙動が非常に特殊なので注意が必要。

pullの注意点「fetchした後、mergeするだけでしょ？」しかし、一部の挙動が特殊。以下のような状況を考える。

ワークツリーにmasterブランチとhogeブランチ。今、masterにいる（*master）→→ $ git pull orogin hoge を実行 →→ ローカルリポジトリの remotes/origin/hoge に情報が取得される ->-> （hogeブランチでなく）masterブランチにhogeブランチがマージされてしまう！！

git pullすると、今自分がいるブランチに、pullしてきたブランチの内容がmergeされる。hogeブランチの情報を取ってくる時に、自分がhogeブランチにいるつもりでうっかり別のブランチに統合してしまったら、ファイルぐちゃぐちゃになる！

ちゃんと理解するまでは、git fetch して git pull というステップを踏んだ方が安全。

師匠の運用ルール：自分がmasterブランチにいて、何の変更もしていない時に限ってgit pullで情報を取得する。





