# もう怖くないGit! チーム開発で必要なGitを完全マスター! 山浦講師

## Gitの設定

.gitconfig に登録したnameとemail

$ git config --global user.name [name]

git で使うエディターを登録 => $ git config --global core.editor "atom --wait"

設定の確認 => $ git config user.name, $ git config user.email

一度に確認したければ => $ git config --list

## Gitは差分でなく、スナップショットを保存している

branchを切る際やmergeする際に、スナップショットだと作業が早い。差分だと、いちいち計算しないといけない。

コミットが、直前のコミットを記録している。

## gitの作業の流れ

ワークツリーでファイルを変更

git add：コミットする変更を準備(記録したい変更分だけをstageに切り分けておく)

git commit：ステージに追加された変更を、スナップショットとしてリポジトリに記録

## コマンドの裏で何が起きているのか〜Gitのデータの持ち方（コミットまでの流れ）

### index.htmlをステージに追加する時、何が起こっているか。

index.html の圧縮ファイルAをリポジトリに保存。（実際は、ファイルの中身にヘッダを付け加えた文字列を、ハッシュ関数で暗号化した文字列がファイル名となる）

git add == ファイル名(index.html)と圧縮ファイルA（ファイルの中身）をmappingした情報をインデックスに保存。

git commit == インデックスのファイル構成を元に、ツリー1というファイルが作られる。次にコミット1というファイルを作る。

コミット1には、ツリー１（ファイル名）、作成者、日付、コミットメッセージが記録される。コミット1から、その時のファイル状態(snap shot)と、誰がいつ何のために変更したのかがわかる。

gitはステージに追加してコミットする際、圧縮ファイル、ツリー、コミットという3種類のファイルを作成してデータを保存している。

### 新しいファイル、css/home.cssを追加したら

git add == css/home.cssの圧縮ファイルBが作成される。インデックスにファイル構成を追記する。

git commit == ツリー2が作成され、インデックスに記載されているファイル構成が保存される。コミット2が作成され、ツリー2というツリー名が記録される。直前のコミット（コミット1）を、自分の親コミットとして記録する。（変更履歴を連鎖してたどれるように）

ステージに追加した時はインデックスという一つのファイルに上書きしておいて、コミット（きちんと記録）する時だけ、ツリーというファイルに保存する。

### ファイルを変更したら

index.htmlだけを変更すると、index.htmlを圧縮した圧縮ファイルCのみがつくられる（圧縮ファイルは、ファイルの中身が違う時だけつくられる）。

インデックスファイルの情報が、index.htmlの圧縮ファイルがAからCに書き換えられる。ここまでが　[$ git add]

ツリー3が作成され、コミット3のツリーはツリー3、親コミットはコミット2となる。[$ git commit]

### Gitのデータ構造のまとめ

リポジトリに「圧縮ファイル」「ツリー」「コミット」ファイルを作成することでデータを保存。ステージに追加する時に「圧縮ファイル」が、コミットする時に「ツリー」「コミット」ファイルが作られる。

コミットが、親コミットへの参照を持つことで、変更履歴をたどることができる。

Gitの本質は、データを圧縮して、スナップショットで保存していること。

## .gitの中身は？

$ ls .git =>  COMMIT_EDITMSG  HEAD  config  description  hooks  index  info  logs  objects  refs

objects：圧縮ファイルやツリーファイル、コミットファイルが保存される、リポジトリの本体

config：Gitの設定ファイル。

## GitHub上にすでにあるプロジェクトから始める

$ git clone <リポジトリ名> => リモートリポジトリのファイルがワークツリーにコピーされ、.gitリポジトリがコピーされる。

### 変更を記録する(commit)

~$ git commit ：Gitのテキストエディターが立ち上がって、メッセージ付きで保存

~$ git commit -m <メッセージ>：いちいち、エディターを立ち上げなくて済む

~$ git commit -v ：エディターが立ち上がり、ファイルの変更内容を確認することができる。

### コミットメッセージの正式な書き方

1行目＝変更内容の要約、2行目＝改行、3行目＝変更した理由（チーム内、オープンソースへのコミットには正式な記法で！）

### 現コミットやステージ追加の前に、どのファイルが変更されたか確認する！

git status => ワークツリーとステージ、ステージとリポジトリの間で変更されたファイルを表示している。

### 変更差分を確認する

$ git diff (<ファイル名>)：git add する前の変更分を確認（ワークツリーと、ステージの変更差分）

$ git diff --staged：git add した後の変更分を確認（ステージとコミットの変更差分）

### 変更履歴の確認

$ git log --oneline ：1行で表示、 $ git log -p <ファイル名>：特定ファイルの変更分を表示、$ git log -n <コミット数>：表示するコミット数を指定
    
git log で表示されるハッシュ値は、コミットのIDのようなもの。

### ファイルの削除を記録する

コミットされた記録だけでなく、ワークツリーのファイルごと削除したい =>　$ git rm <ファイル名> / $ git rm -r <ディレクトリ名>

ワークツリーにファイルは残したいが、Gitの記録からだけファイルを削除したい =>　$ git rm --cached <ファイル名>

例えば、passWordの入ったファイルを間違ってGitにあげてしまったような時は、gir rm --cachedを使う。

### 元の状態に戻す

git rm で削除したファイルを元に戻すには $ git reset HEAD <ファイル名> に続いて、$ git checkout <ファイル名>

この2段構えでファイルが復活し、git status で見ても「変更点がなく」なる。コマンドの意味は、後で詳しく。

git rm --cached index.html を実行すると、ファイルは残っている。git status では、Changes to be commited（コミットすべき変更）として、index.html がdeletedされたこと、Untracked files（Gitで追跡していない、新規ファイル）としてindex.htmlがある、と表示される。

git rm --cached でGitの記録から削除したファイルも、 git reset HEAD index.html で元に戻せる。

### ファイルの移動を記録する

$ git mv <旧ファイル> <新ファイル> これは、下記の3連続コマンドと等価。

$ mv <旧ファイル> <新ファイル> => $ git rm <旧ファイル> => $ git add <新ファイル>

## GitHubにプッシュする

チームメンバーに自分の開発したコードを共有する時、GitHubにローカルの内容を保存したい時。

### リモートリポジトリ(GitHub)を新規追加

$ git remote add origin https://github.com/user/repo.git <-- originというショートカットでurlのリモートリポジトリを登録するよ

今後はoriginという名前で、GitHubリポジトリにアップしたり、取得できるようになる（いちいち、URLを入力せずにすむ）

'origin'はGitの慣用句みたいなもの。git cloneをしてきた時に、clone元のもともとのリモートリポジトリをgitではorigin というショートカットに割り当てている。そのため、メインのリモートリポジトリのことを通常、originと名付ける。

### リモートリポジトリ(GitHub)に送信

$ git push <リモート名> <ブランチ名> 具体的には $ git push origin master

$ git push -u origin master <-- 初回プッシュ時にオプション -u をつけると次回以降は [git push]だけでpushできる。

### GitHubの画面

<>Code でファイルを選択してクリック。Rawは生ファイル、Blameは変更の責任者、Historyはコミット履歴

<>Codeを押して元のページに戻る。commits は個別ファイルのコミット履歴であるHistoryとは異なり、プロジェクト自体のコミット履歴を確認できる。

Clone or download <--他の人のプロジェクトから始めたい場合など

## コマンドにエイリアスをつける

$ git config --global alias.ci commit などで入力を楽に。--globalをつけるとPC全体の設定として~/.gitconfig (or ~/.config/git/config)に反映される。

--globalをつけなければ、今自分がいるプロジェクトの下の　project/.git/configに設定が反映される。

## 管理したくないファイルを無視するには

パスワードなど機密情報が書かれたファイルはバージョン管理から外す。<-- AWSなどのサーバーのpwをバージョン管理してしまい、それが流出・悪用されて多額の請求されるという事故が頻発。

チーム開発で不要なファイル。<- 自動生成されるファイルやキャッシュ。

### .gitignoreファイルの書き方

コメントは #で始める

index.html <- 指定したファイルを除外

/root.html <- ルートディレクトリ(プロジェクトのてっぺん)を指定

dir/ <- ディレクトリ以下を除外(ディレクトリに'/'をつなげる)

/*/*.css <- 一つ下の階層にあるcssファイルすべて

.gitignore を作成したら、それ自体を git add, git commitする。

### ファイルへの変更を取り消す（ワークツリーの）

$ git checkout -- <ファイル名 or ディレクトリ名>

$ git checkout -- . <- 全変更を取り消す

git checkout はブランチの変更の時にも使う。ブランチ名とファイル名が被った時に判別できるように、-- をつける。

### ステージに追加した変更を元に戻す

$ git reset HEAD <ファイル名 or ディレクトリ名>

$ git reset HEAD . <- 全変更を取り消す

このコマンドは、変更をステージから取り消すだけなので、ワークツリー（ローカル）のファイルそのものには影響を与えない。ワークツリーのファイルの変更も取り消したい場合は、git reset HEADをして、その後に、git checkout コマンドでファイルの変更を取り消す必要がある。

git reset コマンドは裏側で何をやっているか。リポジトリから最新コミットの情報を取ってきて、その情報でステージの内容を上書きしている。

HEADとは、今自分がいるブランチの最新のコミットのこと。つまり、$ git reset HEAD = 「最新のコミットの内容でリセット（ステージを上書き）する」

もしgit reset コマンドを忘れても、git statusを打つと(use "git reset HEAD <ファイル名>..." to unstage)と親切に教えてくれる。

### 直前のコミットをやり直す

$ git commit --amend : 今のステージの内容でコミットを上書きする。

!! リモートリポジトリにpushしたコミットは、絶対に修正してはいけない。修正可能なのは、あくまでpushする前のみ！

pushした後に、そのコミットをやり直したい場合は、git commitコマンドでもう一度新しくコミットを作って修正する。

### リモートを表示する

$ git remote : 登録されているリモート名しか表示されない。

$ git remote -v : 対応するURLを表示する。fetch とpushでURLを切り替えることもできるので二つのURLが表示される。

-v：verbose（詳細）の略？

### リモートリポジトリは複数登録できる

チーム開発とは別に、自分でもリモートリポジトリを持っておきたい場合や、複数のチームでやりとりしていて、それぞれのチームでリポジトリを持っている場合など。

$ git remote add <リモート名> <リモートURL> : 例えば、リモート名をorigin でなく bakにしてバックアップ用リポジトリを登録とかできる。（bakというショートカットでリモートリポジトリを登録）

### リモートから取得しよう（fetch編）

$ git fetch <リモート名> : fetch =「取ってくる」

git fetch ではローカルリポジトリに情報を取得してくるだけで、ワークツリー（手元のファイル）には反映されない。

ローカルリポジトリの、remotes/リモート/ブランチ に保存される。

$ git merge : ローカルリポジトリに落として来た内容を、自分のワークツリーにmerge（統合）して反映させる。

(練習用に)リモートリポジトリ上で、新規ファイル（home.html）を作成。Create new file -> Commit directly to the master branch -> Commit new file

$ git fetch origin で情報を取ってくる。どこに保存されているのか？

$ git branch -a ：git branch の全部の情報を表示(-a はall)すると、remotes/origin/master というブランチができている。今いるブランチに * がつく。

先ほどの変更が反映されている remotes/origin/masterの中身を確認するには 

$ git checkout remotes/origin/master ：remotes/origin/master の方に、自分のワークツリーの内容を切り替える

ls で確認すると リモートリポジトリでの変更の反映が確認できる。（新規ファイルhome.htmlがある）

git fetchコマンドで、remotes/origin/master に情報が取得された。

$ git checkout master で元の状態に戻り、lsで確認すると、home.htmlがなく、元々の情報に戻っている。

$ git merge origin/master ：取得してきたリモートリポジトリの情報を、ワークツリーに取り込む。

!! コミットメッセージのエディターが立ち上がらない

git fetch でローカルリポジトリに情報を取得して、その情報をワークツリーに反映させたい場合は git merge コマンドを使う。

### リモートから取得しよう（pull編）

$ git pull <リモート名> <ブランチ名>：リモートから情報を取得してmergeまでを、一つの手順でやりたい時、pullを使う。

$ git pull origin master は $ git pull に省略可能。

$ git pull === ($ git fetch origin master) + ($ git merge origin/master) / fetch とmergeを一度にやるのがpull

git pull を使うと、リモートリポジトリの内容をローカルリポジトリに反映させて、その上で、ワークツリーにもその変更を一度に反映する。ワークツリーまで一度に変更反映したい場合は、git pull

### fetchとpullの使い分け

フェッチを基本的に使うのがおすすめ。プルは確かに楽ではあるが、挙動が非常に特殊なので注意が必要。

pullの注意点「fetchした後、mergeするだけでしょ？」しかし、一部の挙動が特殊。以下のような状況を考える。

ワークツリーにmasterブランチとhogeブランチ。今、masterにいる（*master）→→ $ git pull orogin hoge を実行 →→ ローカルリポジトリの remotes/origin/hoge に情報が取得される ->-> （hogeブランチでなく）masterブランチにhogeブランチがマージされてしまう！！

git pullすると、今自分がいるブランチに、pullしてきたブランチの内容がmergeされる。hogeブランチの情報を取ってくる時に、自分がhogeブランチにいるつもりでうっかり別のブランチに統合してしまったら、ファイルぐちゃぐちゃになる！

ちゃんと理解するまでは、git fetch して git pull というステップを踏んだ方が安全。

師匠の運用ルール：自分がmasterブランチにいて、何の変更もしていない時に限ってgit pullで情報を取得する。

### リモートの詳細情報を表示する

$ git remote show <リモート名>：FetchとPullのURL/リモートブランチ/git pullの挙動/git pushの挙動

### リモートを変更・削除する

$ git remote rename <旧リモート名> <新リモート名>

$ git remote rm <削除するリモート名>

## ブランチとマージ

複数人で開発するにあたり、必須のスキルだが、特にマージは「怖い」と思われがち。

ブランチ：並行して複数機能を開発するためにある。

例：Aさんがヘッダーを修正し、Bさんがレコメンドを追加、それぞれの開発が終わったら大元のマスターブランチに取り込む。

branchを分岐することで、自分の開発が、他メンバーの開発による変更の影響を受けなくてすむ。

### branchのしくみ

gitのデータの持ち方を復習：gitではコミットファイルにparentを指定することで、前のコミットを辿ることができる。つまり、コミットでスナップショットを記録していて、parentで時系列に辿ることができる。

### ブランチというのは、コミットを指し示したポインター

状況として、commit3（最新コミット）をmaster（gitのデフォルトのブランチ）が指している。

コミット3を指す、featureという新しいブランチを作る。

HEAD（gitで作業しているとちょくちょく出てくる単語）とは、今自分が作業しているブランチを指し示したポインタ。

masterブランチとfeatureブランチがコミット3のコミットファイルを指し示している状況で、新しくコミットしたら、masterブランチがコミット4を指し示すように変わる。何が起きているか？？

コミットしたら、ブランチが最新コミットファイルを指し示すように変わる。ブランチはあくまで、コミットファイルを指し示すポインタに過ぎなくて、コミットすると、指し示すポイントが最新のコミットに移動する。こうすることで、今自分が作業しているものの、最新のコミットがどれかがわかる。

コミット3に緊急のバグが発見されて、開発しなくてはいけない状況になった。自分が作業するブランチをfeatureブランチに切り替え、修正してコミット4'（ダッシュ）が作成された。さらに変更を加えて新しいコミットをすると、コミット5'が作成され、それを指し示すようにfeatureブランチも移動。

HEADは今はfeatureブランチを指し示している。

このファイルの全体図を見るとmaster,featureという二つのブランチで、別の開発が並行してできている。開発を分岐させることができる。

### ブランチとHEADの中身

ブランチは、コミットIDを記録したポインタに過ぎない。

HEADの中身は ref:feature （featureブランチを参照）。HEADも非常にシンプルな構造をしており、現在作業中のブランチのファイル名が書いてある、ブランチへのポインタに過ぎない。

master,feature,HEADのファイルはリポジトリの中（.git/の下）に記録されている。（.git/HEAD .git/refs/）

ブランチはコミットを指すポインタ。スナップショットを記録してることと相まって、Gitはブランチの作成や切り替え、マージが他のバージョン管理ツールよりも高速。なぜ高速になるのか？

他のバージョン管理ツールは基本的には、変更差分で記録しているので、ブランチを切り替える際に変更差分を計算しなくてはならない。しかしGitの場合、ブランチの切り替えはスナップショットへのポインターを切り替えるだけ。

その結果、大規模開発において最も使われるツールとなり、普及した。

### ブランチを新規追加する

$ git branch <ブランチ名> ※ ブランチを作成するだけで、ブランチの切り替えまでは行わない。

今masterブランチにいて、$ git branch feature を実行すると、新たにfeatureというブランチが作られる。しかし、HEADはまだmasterにあり、自分がいるブランチは master のまま。

### ブランチの一覧表示

$ git branch ：今あるブランチの一覧を表示。今いるブランチに、* がつく。

$ git branch -a ：リモートリポジトリも含めて、すべてのブランチを表示。

それぞれのブランチがどのコミットを指しているかは、git logコマンドで確認できる。→ $ git log --oneline --decorate

--oneline：ログを単純に一行で表示する。 --decorate：どのブランチが、どのコミットを指しているか。

### ブランチを切り替える

$ git checkout <既存のブランチ名>

$ git checkout -b <新規ブランチ名>：ブランチを新規作成して切り替える。（-bはブランチの略）

feature ブランチに切り替えて、新規ファイルfeature.htmlを作成してコミットした後、$ git checkout masterでmasterブランチに戻る。lsしても、feature.html は存在していない。feature.htmlは、あくまでfeatureブランチで作成したファイルなので。このように、分岐して開発が進められている状態になる。ここで、masterブランチでmaster.html作成という、別の作業をしてみる。

ここまでの状況をGitHubにもアップ。$ git push origin master した後、featureブランチに切り替えて、

$ git checkout feature -> $ git push origin feature

これで、GitHubにはmasterに加えてfeatureブランチができている。

念のため、ローカルリポジトリでmasterブランチに戻っておく。 $ git checkout master

